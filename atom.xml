<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fzzf的博客</title>
  <icon>https://www.gravatar.com/avatar/3f2208dbc1779a11822685122b0e70ae</icon>
  <subtitle>想挣扎无法自拔</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-03-03T07:36:20.958Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Fzzf</name>
    <email>13089186798@163.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>缓存概念简介</title>
    <link href="http://yoursite.com/2020/03/03/%E7%BC%93%E5%AD%98%E6%A6%82%E5%BF%B5%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2020/03/03/%E7%BC%93%E5%AD%98%E6%A6%82%E5%BF%B5%E7%AE%80%E4%BB%8B/</id>
    <published>2020-03-03T07:12:18.794Z</published>
    <updated>2020-03-03T07:36:20.958Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缓存特征"><a href="#缓存特征" class="headerlink" title="缓存特征"></a>缓存特征</h2><h3 id="命中率"><a href="#命中率" class="headerlink" title="命中率"></a>命中率</h3><p>当某个请求能够通过访问缓存而得到响应时，称为缓存命中。</p><p>缓存命中率越高，缓存的利用率也就越高。</p><h3 id="最大空间"><a href="#最大空间" class="headerlink" title="最大空间"></a>最大空间</h3><p>缓存通常位于内存中，内存的空间通常比磁盘空间小的多，因此缓存的最大空间不可能非常大。</p><p>当缓存存放的数据量超过最大空间时，就需要淘汰部分数据来存放新到达的数据。</p><h3 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h3><p><strong>FIFO（First In First Out）：先进先出策略</strong>，在实时性的场景下，需要经常访问最新的数据，那么就可以使用 FIFO，使得最先进入的数据（最晚的数据）被淘汰。</p><p><strong>LRU（Least Recently Used）：最近最久未使用策略</strong>，优先淘汰最久未使用的数据，也就是上次被访问时间距离现在最久的数据。该策略可以保证内存中的数据都是热点数据，也就是经常被访问的数据，从而保证缓存命中率。</p><p><strong>LFU（Least Frequently Used）：最不经常使用策略</strong>，优先淘汰一段时间内使用次数最少的数据。</p><a id="more"></a><h2 id="缓存位置"><a href="#缓存位置" class="headerlink" title="缓存位置"></a>缓存位置</h2><h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><p>当 HTTP 响应允许进行缓存时，浏览器会将 HTML、CSS、JavaScript、图片等静态资源进行缓存。</p><h3 id="ISP"><a href="#ISP" class="headerlink" title="ISP"></a>ISP</h3><p>网络服务提供商（ISP）是网络访问的第一跳，通过将数据缓存在 ISP 中能够大大提高用户的访问速度。</p><h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p>反向代理位于服务器之前，请求与响应都需要经过反向代理。通过将数据缓存在反向代理，在用户请求反向代理时就可以直接使用缓存进行响应。</p><h3 id="本地缓存"><a href="#本地缓存" class="headerlink" title="本地缓存"></a>本地缓存</h3><p>使用 Guava Cache 将数据缓存在服务器本地内存中，服务器代码可以直接读取本地内存中的缓存，速度非常快。</p><h3 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h3><p>使用 Redis、Memcache 等分布式缓存将数据缓存在分布式缓存系统中。</p><p>相对于本地缓存来说，分布式缓存单独部署，可以根据需求分配硬件资源。不仅如此，服务器集群都可以访问分布式缓存，而本地缓存需要在服务器集群之间进行同步，实现难度和性能开销上都非常大。</p><h3 id="数据库缓存"><a href="#数据库缓存" class="headerlink" title="数据库缓存"></a>数据库缓存</h3><p>MySQL 等数据库管理系统具有自己的查询缓存机制来提高查询效率。</p><h3 id="Java-内部的缓存"><a href="#Java-内部的缓存" class="headerlink" title="Java 内部的缓存"></a>Java 内部的缓存</h3><p>Java 为了优化空间，提高字符串、基本数据类型包装类的创建效率，设计了字符串常量池及 Byte、Short、Character、Integer、Long、Boolean 这六种包装类缓冲池。</p><h3 id="CPU-多级缓存"><a href="#CPU-多级缓存" class="headerlink" title="CPU 多级缓存"></a>CPU 多级缓存</h3><p>CPU 为了解决运算速度与主存 IO 速度不匹配的问题，引入了多级缓存结构，同时使用 MESI 等缓存一致性协议来解决多核 CPU 缓存数据一致性的问题。</p><h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><p>内容分发网络（Content distribution network，CDN）是一种互连的网络系统，它利用更靠近用户的服务器从而更快更可靠地将 HTML、CSS、JavaScript、音乐、图片、视频等静态资源分发给用户。</p><p>依靠部署在各地的边缘服务器，通过中心平台的负载均衡，内容分发，，用户就近获取所需内容，降低网络拥塞，提高用户访问相应速度和命中率，关键是内容存储和分发技术。</p><p>归纳起来，CDN具有以下主要功能：</p><p>(1)节省骨干网带宽，减少带宽需求量；  </p><p>(2)提供服务器端加速，解决由于用户访问量大造成的服务器过载问题； </p><p>(3)服务商能使用Web Cache技术在本地缓存用户访问过的Web页面和对象，实现相同对象的访问无须占用主干的出口带宽，并提高用户访问因特网页面的相应时间的需求； </p><p>(4)能克服网站分布不均的问题，并且能降低网站自身建设和维护成本； </p><p>(5)降低“通信风暴”的影响，提高网络访问的稳定性。 </p><p>CDN 主要有以下优点：</p><p>更快地将数据分发给用户；</p><p>通过部署多台服务器，从而提高系统整体的带宽性能；</p><p>多台服务器可以看成是一种冗余机制，从而具有高可用性。</p><h3 id="缓存问题"><a href="#缓存问题" class="headerlink" title="缓存问题"></a>缓存问题</h3><h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p>指的是对某个一定不存在的数据进行请求，该请求将会穿透缓存到达数据库。</p><p>解决方案：</p><p>对这些不存在的数据缓存一个空数据，从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击；</p><p>对这类请求进行过滤，接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;=0的直接拦截；</p><h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><p>缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。</p><p>解决方案：设置热点数据永远不过期。</p><h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><p>指的是由于数据没有被加载到缓存中，或者缓存数据在同一时间大面积失效（过期），又或者缓存服务器宕机，导致大量的请求都到达数据库。</p><p>在有缓存的系统中，系统非常依赖于缓存，缓存分担了很大一部分的数据请求。当发生缓存雪崩时，数据库无法处理这么大的请求，导致数据库崩溃。</p><p>解决方案：</p><p>缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。</p><p>如果缓存数据库是分布式部署，将热点数据均匀分布在不同搞得缓存数据库中。</p><p>设置热点数据永远不过期。</p><h4 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h4><p>缓存一致性要求数据更新的同时缓存数据也能够实时更新。</p><p>解决方案：</p><p>在数据更新的同时立即去更新缓存；</p><p>在读缓存之前先判断缓存是否是最新的，如果不是最新的先进行更新。</p><p>要保证缓存一致性需要付出很大的代价，缓存数据最好是那些对一致性要求不高的数据，允许缓存数据存在一些脏数据。</p><h4 id="缓存-“无底洞”-现象"><a href="#缓存-“无底洞”-现象" class="headerlink" title="缓存 “无底洞” 现象"></a>缓存 “无底洞” 现象</h4><p>指的是为了满足业务要求添加了大量缓存节点，但是性能不但没有好转反而下降了的现象。</p><p>产生原因：缓存系统通常采用 hash 函数将 key 映射到对应的缓存节点，随着缓存节点数目的增加，键值分布到更多的节点上，导致客户端一次批量操作会涉及多次网络操作，这意味着批量操作的耗时会随着节点数目的增加而不断增大。此外，网络连接数变多，对节点的性能也有一定影响。</p><p>解决方案：</p><p>优化批量数据操作命令；</p><p>减少网络通信次数；</p><p>降低接入成本，使用长连接 / 连接池，NIO 等。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缓存特征&quot;&gt;&lt;a href=&quot;#缓存特征&quot; class=&quot;headerlink&quot; title=&quot;缓存特征&quot;&gt;&lt;/a&gt;缓存特征&lt;/h2&gt;&lt;h3 id=&quot;命中率&quot;&gt;&lt;a href=&quot;#命中率&quot; class=&quot;headerlink&quot; title=&quot;命中率&quot;&gt;&lt;/a&gt;命中率&lt;/h3&gt;&lt;p&gt;当某个请求能够通过访问缓存而得到响应时，称为缓存命中。&lt;/p&gt;
&lt;p&gt;缓存命中率越高，缓存的利用率也就越高。&lt;/p&gt;
&lt;h3 id=&quot;最大空间&quot;&gt;&lt;a href=&quot;#最大空间&quot; class=&quot;headerlink&quot; title=&quot;最大空间&quot;&gt;&lt;/a&gt;最大空间&lt;/h3&gt;&lt;p&gt;缓存通常位于内存中，内存的空间通常比磁盘空间小的多，因此缓存的最大空间不可能非常大。&lt;/p&gt;
&lt;p&gt;当缓存存放的数据量超过最大空间时，就需要淘汰部分数据来存放新到达的数据。&lt;/p&gt;
&lt;h3 id=&quot;淘汰策略&quot;&gt;&lt;a href=&quot;#淘汰策略&quot; class=&quot;headerlink&quot; title=&quot;淘汰策略&quot;&gt;&lt;/a&gt;淘汰策略&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;FIFO（First In First Out）：先进先出策略&lt;/strong&gt;，在实时性的场景下，需要经常访问最新的数据，那么就可以使用 FIFO，使得最先进入的数据（最晚的数据）被淘汰。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LRU（Least Recently Used）：最近最久未使用策略&lt;/strong&gt;，优先淘汰最久未使用的数据，也就是上次被访问时间距离现在最久的数据。该策略可以保证内存中的数据都是热点数据，也就是经常被访问的数据，从而保证缓存命中率。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LFU（Least Frequently Used）：最不经常使用策略&lt;/strong&gt;，优先淘汰一段时间内使用次数最少的数据。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>论文翻译</title>
    <link href="http://yoursite.com/2020/03/02/%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91/"/>
    <id>http://yoursite.com/2020/03/02/%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91/</id>
    <published>2020-03-02T10:39:48.322Z</published>
    <updated>2020-03-03T09:40:18.201Z</updated>
    
    <content type="html"><![CDATA[<p>A Little Annotation does a Lot of Good:<br>A Study in Bootstrapping Low-resource Named Entity Recognizers 译文</p><h1 id="很少的标注有很多好处：低资源的命名实体识别研究"><a href="#很少的标注有很多好处：低资源的命名实体识别研究" class="headerlink" title="很少的标注有很多好处：低资源的命名实体识别研究"></a>很少的标注有很多好处：低资源的命名实体识别研究</h1><p>卡内基梅隆大学语言技术研究所</p><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>大多数命名实体识别（NER）的最新模型都依赖于大量标记数据的可用性，这使它们很难扩展到资源较少的新语言。 但是，现在有几种提议的方法，涉及跨语言的迁移学习（从其他资源丰富的语言中学习）或主动学习，该方法基于模型预测有效地选择有效的训练数据。 本文提出了一个问题：鉴于最近的进展，以及有限的人工标注，以资源不足的语言有效创建高质量实体识别器的最有效方法是什么？基于使用模拟和真实人类标注的广泛实验，我们找到了最好的双重策略方法，首先是使用跨语言传输模型，然后仅对目标语言中不确定的实体范围执行目标标注，从而最大程度地减少标注者的工作量。 结果表明，当可以标注很少的数据时，跨语言传输是一种强大的工具，但是以实体为目标的标注策略只需训练数据的十分之一即可快速实现竞争准确性。 本方法的代码可在此处公开获得。</p><a id="more"></a><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2><p>命名实体识别（NER）的任务是检测文本中的命名实体并将其分类为一组固定的预定义类别（人员，位置等），并具有多个下游应用程序，包括机器读取（Chen等，2017）实体和事件的共同引用（Yang和Mitchell，2016）以及文本挖掘（Han和Sun，2012）。深度学习的最新进展已在许多序列标记任务（包括NER）上取得了最先进的表现（Collobert等，2011; Ma and Hovy，2016; Lample等，2016; Peters等，2018）。但是，这些模型的性能高度依赖于大量带标注的数据的可用性，因此，对于资源少于英语的语言，其准确性明显较低。在这项工作中，我们提出了一个问题：“我们如何才能有效地帮助一稿高质量的命名实体识别器，用于低资源语言，并且只有少量的人类努力？具体来说，我们利用低资源语言数据高效学习的最新进展，提出了以下引导低资源实体识别器的”配方”：首先，我们使用跨语言迁移学习（Yarowsky等人，2001； Ammar等人等人（2016年），将在另一种语言上训练的模型应用于资源匮乏的语言，以提供良好的初步模型来启动引导过程。具体来说，我们使用谢等人的模型。（2018），报告对多种语言对的强劲结果。接下来，在这种迁移模型的基础上，我们进一步采用主动学习（Settles和Craven，2008； Marchegigiani和Artieres，2014），这通过使用模型预测为人类标注者选择信息性而非随机数据来帮助提高标注效率。最后，根据使用主动学习获得的数据对模型进行微调，以提高目标语言的准确性。</p><p>​    在此配方中，选择用于在主动学习中选择和标注数据的特定方法对于最大限度地减少人工工作非常重要。 在NER的先前工作中使用的一种相对标准的方法是，根据识别其中的实体的不确定性的标准来选择完整序列（Culotta和McCallum，2005年）。然而，由于通常只关注句子中的单个实体，因此当仅关注句子的一小部分时，标注整个序列仍然是乏味且浪费的（Neubig等人，2011年； Sperber等，2014）。 受此发现启发，并考虑到命名实体既重要又稀疏的事实，我们提出了一种以实体为目标的策略，以节省标注者的工作量。 具体来说，我们选择序列中最可能命名的实体的不确定的令牌子跨度。 这样，标注者只需要将类型分配给选定的子跨度，而不必读取和标注整个序列。 为了应付序列的部分标注，我们在训练过程中仅从带标注的子跨度中学习使用条件随机字段（CRF）的约束版本，即部分CRF（Tsuboi等，2008年； Wanvarie等，2011）。</p><p>​    为了评估我们的实验方法，我们用5种语言进行了模拟的主动学习实验：西班牙语、荷兰语、德语、印地语和印度尼西亚语。此外，为了在更实际的环境中研究我们的方法，我们对两个低资源语言（印度尼西亚语和印地语）和一种模拟低资源语言西班牙语进行了人工标注实验。总之，本文作出以下贡献：</p><p>1.我们提出了改进低资源 NER 的引导配方。只需使用十分之一的标记，我们提议的 entity 定向主动学习方法可在所有活动学习基线中提供最佳结果，平均改进为 9.9 F1。</p><p>2.通过模拟实验，我们证明，跨语言传输是一个强大的工具，在仅对十分之一的标记进行批过时，比未传输系统在F1值上平均高8.6。</p><p>3.人工标注实验表明，在使用实体目标策略（而不是完整序列标注）时，标注者在标注实体方面更准确。此外，T 他的策略通过要求它们标记的标记比全序列标注更少的标记来最小化标注器工作量。</p><h2 id="2-方法"><a href="#2-方法" class="headerlink" title="2.方法"></a>2.方法</h2><p>如导言所述，我们的引导食谱由三个部分组成：（1）跨语言迁移学习；（2）主动学习以选择要标注的数据的相关（3）在这些带标注的线段上对模型进行微调。 继续步骤（2）和（3），直到模型达到可接受的准确性水平，或者直到我们用完标注预算为止。 系统概述如图1所示。在以下各节中，我们将详细描述这三个步骤。</p><p>​        <img src="http://fzzf-blog.oss-cn-beijing.aliyuncs.com/img/1583147204947.png" alt="">                                                                                                    </p><p>图1：我们建议的配方：跨语言传输用于从英语标签投射标注将数据集转换为目标语言。 然后，以实体为目标的主动学习用于选择内容丰富的子跨度，可能是人类要标注的实体。 最后，在此部分标记的数据集上对NER模型进行微调。</p><h3 id="2-1跨语言迁移学习"><a href="#2-1跨语言迁移学习" class="headerlink" title="2.1跨语言迁移学习"></a>2.1跨语言迁移学习</h3><p>跨语言学习的目标是让接受过源语言培训的识别器进行迁移将其转换为目标语言。 我们这样做的NER方法效仿Xie等.（2018），我们在本节中进行简要回顾。</p><p>首先，我们假设访问两组预先训练的单语单词嵌入在源语言和目标语言中，X   和 <em>Y，</em>一个小型双语词典，以无监督的方式提供或获取（Artetxe 等人）。2017;康纳等人  ，2017a），并在源语言中标记训练数据。利用这些资源，我们训练双语单词嵌入（BWE） 以创建一个单词对单词的翻译字典，最后使用此字典将源训练数据转换为目标language，我们用它来训练 NER 模型。</p><p>为了学习BWE，我们首先通过求解以下目标获得线性映射<em>W：</em> </p><p><em>W*<em>=  = argmink</em>WXD</em>  =<em>YD<em>k</em>F</em>  s.t.<em>WW</em>&gt;  =  <em>I</em>，*</p><p>其中<em>XD*和 *YD</em> 对应于双语词典中的对齐词嵌入。<em>F</em> 表示弗罗贝尼乌斯规范。我们可以首先计算奇异值分解<em>YDT</em>  <em>X D</em>  =  <em>U</em>  P<em>V</em>  &gt;， 并通过采用<em>W</em>=  UV    &gt;求解目标。我们通过线性变换源和目标单语词嵌入U和<em>V，</em>即<em>XU</em>和<em>YV</em>来获得BWE。</p><p>获得 BWE 后，我们使用跨域相似性局部缩放 （CSLS） 指标（Connau 等人） 为 BWE 空间中的每个源字找到最近的邻域目标字。(Conneau  ，2017b），它产生一个单词对单词的翻译字典。我们使用 thi字典将源训练数据翻译成目标语言，只需复制每个单词的标签，即可生成以目标语言传输的训练数据。我们基于此传输的数据训练 NER 模型作为初步模型。展望未来，我们将跨语言传输数据的使用称为 CT。</p><h3 id="2-2实体目标活动学习"><a href="#2-2实体目标活动学习" class="headerlink" title="2.2实体目标活动学习"></a>2.2实体目标活动学习</h3><p>使用跨语言转移学习训练模型后，我们基于该模型的输出开始主动学习过程。首先，我们使用上述模型的输出作为训练数据，对 NER 模型进行训练。使用这个经过训练的模型，我们提出的以实体为目标的活动学习策略（称为 ETAL）然后从未标记序列的<em>D</em> 体中选择信息最丰富的范围。给定未标记的序列，ETAL首先选择一个令牌的范围从   <em>ji</em>  =  <em>si</em>  |<em>sj*这样 s  *ji</em> 是一个可能的命名实体，其中 <em>i，j</em>  = {0}<em>s</em>|.然后，为了获得跨 D 的高度信息范围，ETAL计算 <em>D</em> 中span <em>ji</em>每次发生的熵 <em>H，</em>然后将它们聚合到整个主体<em>D</em>上，给出：</p><p><em>H<strong>聚合<em>（</em>与</strong>它<em>） =X *H</em>（<em>x*</em>ji<em>）1（</em>x**ji</em> = <em>s**）</em></p><p><em>x**ji-D</em>    </p><p>其中<em>x</em>是<em>D</em>中的未标记序列。最后，选择具有最高聚合不确定性<em>H聚合<em>的跨度</em>ji</em> 进行手动标注。</p><p>现在，我们描述了计算 H （<em>xji<em>）的过程，这是一个范围</em>xji<em>的熵，可能是一个实体。给定一个未标记的序列x，</em>训练的 NER 模型 <em>用于计算边际概率 *p=</em>（y*i</em>=<strong>x</strong>）每个令牌 <em>xi<em>跨所有可能的标签 <em>yi</em></em>Y</em> 使用前向后向算法（Rabiner， 1989），其中 <em>Y</em> 是所有标签的集。使用这些边际值，我们计算给定范围<em>xji</em> 的熵，如算法 1所示。</p><p><img src="https://fzzf-blog.oss-cn-beijing.aliyuncs.com/img/%E5%85%AC%E5%BC%8F.png" alt=""></p><p>让<em>B</em> 表示指示实体开头的标签集，I   表示实体内部的标签集，O   表示实体外部的标签集。首先，我们计算一个范围<em>xji</em> 成为实体的概率，从令牌 <em>i</em>开始，通过边缘化 <em>p=<em>（y</em>i</em>|<strong>x</strong>）在<em>B</em>中的所有标签上，表示为 <em>pij范围<em>。由于实体可以跨越多个令牌，因此，对于作为该实体的一部分，我们将</em>p=<em>（y</em>j</em>|<strong>x</strong>） 在I的所有标签，并结合它与<em>pij跨度<em>。最后，我们计算</em>p**实体</em> =  <em>p**ijspan</em>  =  <em>p<strong>=<em>（</em>O</strong>j</em>=<strong>x**</strong>），*<em>表示可能实体的结束。由于我们使用边际概率来计算 *p实体</em>，它已经在标记之间的转换概率中考虑了。</p><p>因此，任何无效序列（如<em>BPERIORG*</em>）<em>的分数都很低。由于连续范围具有 ovlapping标记，因此在考虑序列中的所有可能范围时，使用动态规划 （DP） 来计算 *pij范围</em>可以避免指数计算。使用 <em>p实体</em>，我们计算熵 <em>H，</em>并仅考虑大于预定义的阈值 <em>H阈值</em>的跨度。此阈值的原因纯粹是为了计算目的，因为它允许我们丢弃所有具有非常低的实体概率的跨距，从而将实际存储在内存中的跨数保持在较低水平。如前所述，我们在整个未标记集上聚合范围<em>H聚合</em>的熵，从而将不确定采样与对高频实体的偏置相结合。</p><p>使用此策略，我们为每个序列中选择子跨进行标注。标注人员仅指定指定实体类型以分配给所选子跨度，根据需要调整范围边界，然后忽略序列的其余部分，从而节省大量精力。</p><h3 id="2-3训练NER-模型"><a href="#2-3训练NER-模型" class="headerlink" title="2.3训练NER 模型"></a>2.3训练NER 模型</h3><p>利用主动学习中新获得的训练数据，我们尝试改进原始的迁移模型。在本节中，我们首先描述我们的模型架构，并尝试解决：1）如何使用部分标注的序列有效地训练NER模型？ 2）哪种训练方案最适合改进迁移模型？</p><h4 id="2-3-1模型结构"><a href="#2-3-1模型结构" class="headerlink" title="2.3.1模型结构"></a>2.3.1模型结构</h4><p>我们的NER模型是基于Ma和Hovy（2016）的BiLSTM-CNN-CRF模型，包括：字符级CNN，该模型可以捕获子词信息；单词级别的BiLSTM，使用单词嵌入并产生上下文相关的隐藏表示；以及一个线性链CRF层，该层对标签之间的依赖关系进行建模以进行推理。我们使用上述模型对传输的数据训练初始NER模型，并对从主动学习中获取的数据重新训练模型。</p><h4 id="2-3-2-PARTIAL-CRF"><a href="#2-3-2-PARTIAL-CRF" class="headerlink" title="2.3.2 PARTIAL-CRF"></a>2.3.2 PARTIAL-CRF</h4><p>使用基于跨距的策略（如ETAL）进行主动学习，可生成部分标记序列的训练数据集。为了在这些部分标记的序列上训练NER模型，我们从贝勒和麦卡勒姆（2007年）中汲取灵感;筑波等人（2008） 并使用受约束的 CRF 解码器.通常，CRF 计算给定序列 <strong>x</strong>的标签序列 y 的可能性，如下所示：</p><h4 id="2-3-3训练计划"><a href="#2-3-3训练计划" class="headerlink" title="2.3.3训练计划"></a>2.3.3训练计划</h4><p>为了使用新标记的数据改进我们的模型，我们直接根据传输的数据对初始模型进行微调，这些数据基于通过主动学习获得的数据（称为FINETUNE） 进行微调。每次主动学习运行会产生更多标记数据，对此训练过程将再次重复。我们还使用另外两个培训计划比较 NER 性能：CORPUSAUG，在其中，我们根据传输的数据和新获取的数据的串联主体训练模型，以及 CORPUSAUG+FINETUNE，我们另外使用新获得的数据对 CORPUSAUG训练的模型进行微调。</p><h2 id="3-实验"><a href="#3-实验" class="headerlink" title="3 实验"></a>3 实验</h2><h3 id="3-1实验设置"><a href="#3-1实验设置" class="headerlink" title="3.1实验设置"></a>3.1实验设置</h3><p>数据集：第一个评估集包括基准的CoNLL 2002和2003 NER数据集（Tjong Kim Sang，2002； Tjong Kim Sang和De Meulder，2003），用于西班牙语（来自罗曼史家族），荷兰语和德语（如英语，来自日耳曼语系）家庭）。我们将标准语料库拆分用于训练/验证/测试。第二个评估集是针对资源匮乏的环境，在这里我们使用语言数据协会（LDC）发布的印尼语（来自南岛人），印地语（来自印度－雅利安人）和西班牙数据集。训练集，验证集，测试集 通过随机抽样拆分。语料库统计的详细信息在附录§A.1中。</p><p>英文的翻译数据：我们使用与Xie等人所述相同的实验设置和资源。 （2018）获取每种目标语言的英语培训数据的翻译。</p><p>主动学习设置：第2.2节中介绍的s，使用基于 DP 的算法来选择针对长度*&lt;*= 5的所有 n-gram 运行的不确定实体跨度。通过计算英语 train g 数据中实体长度的第 90 个百分位数，近似于此长度。</p><p><em>H*</em>阈值*是设置为 1e-8 的超参数。NER模型超参数的详细信息可在附录 #A.2中找到。</p><h3 id="3-2模拟实验"><a href="#3-2模拟实验" class="headerlink" title="3.2模拟实验"></a>3.2模拟实验</h3><p><strong>设置</strong>：我们使用跨语言传输 （§2.1） 来训练我们的初始 NER 模型，并在目标语言上进行测试。这与谢等人的设置相同。（2018） 并作为我们的基准.然后，我们使用几种主动学习策略来选择数据，以便使用此经过训练的 NER 模型进行手动标注。我们将我们提议的ETAL 策略与以下基线策略进行比较。</p><p><strong>SAL</strong>：选择模型对最可能的标记缺乏信心的整个序列（Culotta和McCallum，2005年）。</p><p><strong>CFEAL</strong>：使用置信度域估计方法（Culotta和McCallum，2004年）选择序列中的最低置信度。</p><p><strong>RAND</strong>：从未标记的集合中随机选择跨度以进行标注。</p><p>在此实验设置中，我们通过对主动学习选择的数据使用金色标签来模拟手动标注。在随后的每次运行中，我们都对200个令牌进行标注，并对到目前为止获取的所有数据微调NER模型，然后将其用于选择用于下一轮标注的数据。</p><h4 id="3-2-1结果"><a href="#3-2-1结果" class="headerlink" title="3.2.1结果"></a>3.2.1结果</h4><p>图2总结了不同实验设置下所有数据集的结果。在标注了200个附加令牌之后，x轴上的每个数据点都对应于NER性能。 CT表示使用跨语言传输的数据来训练初始NER模型，从而既可以启动主动学习过程，又可以对新获取的数据进行NER模型的微调。 PARTIAL-CRF / FULL-CRF表示NER模型中使用的CRF解码器的类型。除非另有说明，否则在本文中，我们报告的是所有主动学习运行的平均结果。个人分数在附录§A.5中报告。</p><p>从图中可以看出，我们建议的配方ETAL + PARTIAL-CRF + CT优于以前的配方优于所有数据集的主动动学习基线。保持CT和PARTIALCRF的其他两个分量不变，我们进行实验，以比较不同的主动学习，用图2中的实线表示。我们看到，ETAL 在 CoNLL 数据集中明显优于其他策略：德语 （+6.1 F1）、西班牙语 （+5.3 F1）、荷兰语 （+6.3F1） 和最不发达国家数据集：印地语 （+9.3 F1）、Indone（+9.0 F1）、西班牙语 （+7.5 F1）在所有运行结束时。此外，即使只有十分之一的带标注的令牌，建议的配方也仅落后于使用所有标记数据（用SUPERVISED ALL表示）训练的模型平均-5.2 F1。尽管CFEAL也会选择信息范围，但ETAL却胜过它，因为ETAL已优化为选择可能的实体，从而导致更多的实体被标注为印地语（+43），印度尼西亚语（+207），西班牙语-CoNLL（+1579），德语（+906） ），荷兰语（+836），但西班牙文-LDC（-184）除外。尽管在SAL中添加了完全标记的数据，但ETAL却胜过它，因为SAL选择了更长的句子且实体更少：北印度语（-934），印度尼西亚语（-1290），西班牙文LDC（-527），西班牙文CoNLL（-2395），德语（- 2086年），荷兰语（-2213年）。</p><p>从图2中可以看出，多次运行ETAL的性能均优于基线。为了验证这不是测试数据中的随机现象，我们使用配对的自举重采样方法（如Koehn（2004）所示）将SAL，CFEAL，RAND与ETAL进行比较。对于每个系统，我们在随机采样的50％数据上计算F1分数，并在三个主动学习运行中执行10k引导步骤。从表1中可以看出，在600和1200带标注的令牌上，基线明显比ETAL差。</p><p><img src="https://fzzf-blog.oss-cn-beijing.aliyuncs.com/img/figure2.png" alt=""></p><p>图2：在六个数据集中使用FineTune方案训练的NER性能的比较。实线比较了不同的主动学习策略。虚线表示消融实验。 x轴表示带标注的令牌总数，y轴表示F1分数。</p><h4 id="3-2-2-消融研究"><a href="#3-2-2-消融研究" class="headerlink" title="3.2.2 消融研究"></a>3.2.2 消融研究</h4><p>为了研究CT和PARTIAL-CRF在改善NER性能方面的贡献，我们进行了以下消融，在图2中用虚线表示。</p><p>CT：我们观察到从英语传输的数据为NER模型提供了一个良好的开端：69.4（荷兰语），63.0（西班牙语-LDC），65.7（SpanishCoNLL），54.7（德语），45.4（印尼语），45.0（印地语） F1不出所料，跨语言迁移对与英语紧密相关的语言（荷兰语，德语，西班牙语）的帮助更大。对于这种消融，我们训练一个ETAL + PARTIAL-CRF，其中不使用任何传输的数据。因此，要创建种子数据，我们将以目标语言随机标注200个令牌，然后使用ETAL。我们观察到，随着获取更多的域内数据，未转移的设置很快就会接近转移的设置ETAL + PARTIAL-CRF + CT，这表明有效的标注策略可以帮助缩小这两个系统之间的距离，而间隔仅为1000令牌（平均）。</p><p>PARTIAL-CRF：我们研究使用原始CRF（FULL-CRF）代替PARTIALCRF训练带有部分标记数据的效果。由于前者需要完全标记的序列，因此序列中未标注的标记会用模型预测标记。从图2中我们可以看到，与ETAL + PARTIAL-CRF + CT相比，ETAL + FULL-CRF + CT的性能更差（平均-4.1 F1）。这是因为FULL-CRF严重影响了召回，印地语平均为-11.0点，印尼语为-1.4，西班牙语-LDC为-7.4，德语为-3.3，荷兰语为-3.7，西班牙CoNLL为-4.8分。</p><h4 id="3-2-3训练计划比较"><a href="#3-2-3训练计划比较" class="headerlink" title="3.2.3训练计划比较"></a>3.2.3训练计划比较</h4><p>我们针对ETAL尝试了不同的NER培训制度（在第2.3.3节中进行了介绍）。我们观察到，与CORPUSAUG相比，通常微调不仅可以加快训练速度，而且可以提供更好的性能。为了简短起见，我们在图3中比较了两种语言的结果：3荷兰语（英语的亲戚）和印地语（遥远的语言）。我们看到FINETUNE对印地语的表现更好，而CORPUSAUG + FINETUNE对荷兰语的表现更好。这是因为荷兰语与英语密切相关，并且从显式扩充的传输数据中受益最大。而北印度语在类型上与英语相距遥远，而传输的数据则比较嘈杂，因此该模型不会从传输的数据中获得太多收益。卸等人在对德语的实验中也有类似的观察。</p><h3 id="3-3人工标注实验"><a href="#3-3人工标注实验" class="headerlink" title="3.3人工标注实验"></a>3.3人工标注实验</h3><p>设置：我们对印地语，印度尼西亚语和西班牙语进行了人工标注实验，以了解ETAL在实际设置中是否有助于减少标注工作并提高标注质量。我们将ETAL与全序列策略（SAL）进行比较。我们使用六位母语使用者，每种语言两位，对NER任务的熟悉程度不同。为每个标注者提供了练习，以熟悉标注准则和用户界面。每个策略的标注者标注时间为20分钟。对于ETAL，要求标注者对单个范围进行标注，即每个序列都包含一个令牌范围。这涉及分配正确的标签并根据需要调整跨度边界。对于SAL，要求标注者对序列中所有可能的实体进行标注。我们使用ETAL和SAL策略随机化了标注者必须进行标注的顺序。图5说明了标注界面中ETAL策略的人工标注过程。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;A Little Annotation does a Lot of Good:&lt;br&gt;A Study in Bootstrapping Low-resource Named Entity Recognizers 译文&lt;/p&gt;
&lt;h1 id=&quot;很少的标注有很多好处：低资源的命名实体识别研究&quot;&gt;&lt;a href=&quot;#很少的标注有很多好处：低资源的命名实体识别研究&quot; class=&quot;headerlink&quot; title=&quot;很少的标注有很多好处：低资源的命名实体识别研究&quot;&gt;&lt;/a&gt;很少的标注有很多好处：低资源的命名实体识别研究&lt;/h1&gt;&lt;p&gt;卡内基梅隆大学语言技术研究所&lt;/p&gt;
&lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;大多数命名实体识别（NER）的最新模型都依赖于大量标记数据的可用性，这使它们很难扩展到资源较少的新语言。 但是，现在有几种提议的方法，涉及跨语言的迁移学习（从其他资源丰富的语言中学习）或主动学习，该方法基于模型预测有效地选择有效的训练数据。 本文提出了一个问题：鉴于最近的进展，以及有限的人工标注，以资源不足的语言有效创建高质量实体识别器的最有效方法是什么？基于使用模拟和真实人类标注的广泛实验，我们找到了最好的双重策略方法，首先是使用跨语言传输模型，然后仅对目标语言中不确定的实体范围执行目标标注，从而最大程度地减少标注者的工作量。 结果表明，当可以标注很少的数据时，跨语言传输是一种强大的工具，但是以实体为目标的标注策略只需训练数据的十分之一即可快速实现竞争准确性。 本方法的代码可在此处公开获得。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>SQL语言基础（持续更新）</title>
    <link href="http://yoursite.com/2020/03/02/SQL%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/02/SQL%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/</id>
    <published>2020-03-02T05:44:50.761Z</published>
    <updated>2020-03-03T07:10:16.080Z</updated>
    
    <content type="html"><![CDATA[<h3 id="注释："><a href="#注释：" class="headerlink" title="注释："></a>注释：</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注释</span></span><br><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> mytable; <span class="comment">-- 注释</span></span><br><span class="line"><span class="comment">/* 注释1</span></span><br><span class="line"><span class="comment">   注释2 */</span></span><br></pre></td></tr></table></figure><h3 id="数据库创建以及使用："><a href="#数据库创建以及使用：" class="headerlink" title="数据库创建以及使用："></a>数据库创建以及使用：</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> <span class="keyword">test</span>;</span><br><span class="line"><span class="keyword">USE</span> <span class="keyword">test</span>;</span><br></pre></td></tr></table></figure><h3 id="创建表："><a href="#创建表：" class="headerlink" title="创建表："></a>创建表：</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> mytable (</span><br><span class="line">  <span class="comment"># int 类型，不为空，自增</span></span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="comment"># int 类型，不可为空，默认值为 1，不为空</span></span><br><span class="line">  col1 <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">1</span>,</span><br><span class="line">  <span class="comment"># 变长字符串类型，最长为 45 个字符，可以为空</span></span><br><span class="line">  col2 <span class="built_in">VARCHAR</span>(<span class="number">45</span>) <span class="literal">NULL</span>,</span><br><span class="line">  <span class="comment"># 日期类型，可为空</span></span><br><span class="line">  col3 <span class="built_in">DATE</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="comment"># 设置主键为 id</span></span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>));</span><br></pre></td></tr></table></figure><h3 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h3><h4 id="添加列"><a href="#添加列" class="headerlink" title="添加列"></a>添加列</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE mytable</span><br><span class="line">ADD col CHAR(20);</span><br></pre></td></tr></table></figure><h4 id="删除列"><a href="#删除列" class="headerlink" title="删除列"></a>删除列</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE mytable</span><br><span class="line">DROP COLUMN col;</span><br></pre></td></tr></table></figure><h4 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> mytable;</span><br></pre></td></tr></table></figure><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><h4 id="普通插入"><a href="#普通插入" class="headerlink" title="普通插入"></a>普通插入</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> mytable(col1, col2)</span><br><span class="line"><span class="keyword">VALUES</span>(val1, val2);</span><br></pre></td></tr></table></figure><h4 id="插入检索出来的数据"><a href="#插入检索出来的数据" class="headerlink" title="插入检索出来的数据"></a>插入检索出来的数据</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> mytable1(col1, col2)</span><br><span class="line"><span class="keyword">SELECT</span> col1, col2</span><br><span class="line"><span class="keyword">FROM</span> mytable2;</span><br></pre></td></tr></table></figure><h4 id="将一个表的内容插入到一个新表"><a href="#将一个表的内容插入到一个新表" class="headerlink" title="将一个表的内容插入到一个新表"></a>将一个表的内容插入到一个新表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> newtable <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> mytable;</span><br></pre></td></tr></table></figure><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> mytable</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">col</span> = val</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><strong>TRUNCATE TABLE</strong> 可以清空表，也就是删除所有行。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> mytable;</span><br></pre></td></tr></table></figure><p>使用更新和删除操作时一定要用 WHERE 子句，不然会把整张表的数据都破坏。可以先用 SELECT 语句进行测试，防止错误删除。</p><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><h4 id="DISTINCT"><a href="#DISTINCT" class="headerlink" title="DISTINCT"></a>DISTINCT</h4><p>相同值只会出现一次。它作用于所有列，也就是说所有列的值都相同才算相同。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> col1, col2</span><br><span class="line"><span class="keyword">FROM</span> mytable;</span><br></pre></td></tr></table></figure><h4 id="LIMIT"><a href="#LIMIT" class="headerlink" title="LIMIT"></a>LIMIT</h4><p>限制返回的行数。可以有两个参数，第一个参数为起始行，从 0 开始；第二个参数为返回的总行数。</p><p>返回前 5 行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">0</span>, <span class="number">5</span>;</span><br></pre></td></tr></table></figure><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><ul><li><strong>ASC</strong> ：升序（默认）</li><li><strong>DESC</strong> ：降序</li></ul><p>可以按多个列进行排序，并且为每个列指定不同的排序方式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> col1 <span class="keyword">DESC</span>, col2 <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure><h4 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h4><p>通配符也是用在过滤语句中，但它只能用于文本字段。</p><ul><li><strong>%</strong> 匹配 &gt;=0 个任意字符；</li><li><strong>_</strong> 匹配 ==1 个任意字符；</li><li><strong>[ ]</strong> 可以匹配集合内的字符，例如 [ab] 将匹配字符 a 或者 b。用脱字符 ^ 可以对其进行否定，也就是不匹配集合内的字符。</li></ul><p>使用 Like 来进行通配符匹配，模糊匹配。</p><h3 id="计算字段"><a href="#计算字段" class="headerlink" title="计算字段"></a>计算字段</h3><p>在数据库服务器上完成数据的转换和格式化的工作往往比客户端上快得多，并且转换和格式化后的数据量更少的话可以减少网络通信量。</p><p>计算字段通常需要使用 <strong>AS</strong> 来取别名，否则输出的时候字段名为计算表达式。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col1 * col2 <span class="keyword">AS</span> <span class="keyword">alias</span></span><br><span class="line"><span class="keyword">FROM</span> mytable;</span><br></pre></td></tr></table></figure><p><strong>CONCAT()</strong> 用于连接两个字段。许多数据库会使用空格把一个值填充为列宽，因此连接的结果会出现一些不必要的空格，使用 <strong>TRIM()</strong> 可以去除首尾空格。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CONCAT</span>(<span class="keyword">TRIM</span>(col1), <span class="string">'('</span>, <span class="keyword">TRIM</span>(col2), <span class="string">')'</span>) <span class="keyword">AS</span> concat_col</span><br><span class="line"><span class="keyword">FROM</span> mytable;</span><br></pre></td></tr></table></figure><h1 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h1><p>把具有相同的数据值的行放在同一组中。</p><p>可以对同一分组数据使用汇总函数进行处理，例如求分组数据的平均值等。</p><p>指定的分组字段除了能按该字段进行分组，也会自动按该字段进行排序。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">col</span>, <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> <span class="keyword">num</span></span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">col</span>;</span><br></pre></td></tr></table></figure><p>GROUP BY 自动按分组字段进行排序，ORDER BY 也可以按汇总字段来进行排序。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">col</span>, <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> <span class="keyword">num</span></span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">col</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">num</span>;</span><br></pre></td></tr></table></figure><p>WHERE 过滤行，HAVING 过滤分组，行过滤应当先于分组过滤。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">col</span>, <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> <span class="keyword">num</span></span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">col</span> &gt; <span class="number">2</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">col</span></span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">num</span> &gt;= <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>分组规定：</p><ul><li>GROUP BY 子句出现在 WHERE 子句之后，ORDER BY 子句之前；</li><li>除了汇总字段外，SELECT 语句中的每一字段都必须在 GROUP BY 子句中给出；</li><li>NULL 的行会单独分为一组；</li><li>大多数 SQL 实现不支持 GROUP BY 列具有可变长度的数据类型。</li></ul><h1 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h1><p>子查询中只能返回一个字段的数据。</p><p>可以将子查询的结果作为 where 语句的过滤条件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM mytable1</span><br><span class="line">WHERE col1 IN (SELECT col2</span><br><span class="line">               FROM mytable2);</span><br></pre></td></tr></table></figure><p>下面的语句可以检索出客户的订单数量，子查询语句会对第一个查询检索出的每个客户执行一次：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, (<span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*)</span><br><span class="line">                   <span class="keyword">FROM</span> Orders</span><br><span class="line">                   <span class="keyword">WHERE</span> Orders.cust_id = Customers.cust_id)</span><br><span class="line">                   <span class="keyword">AS</span> orders_num</span><br><span class="line"><span class="keyword">FROM</span> Customers</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> cust_name;</span><br></pre></td></tr></table></figure><h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><p>连接用于连接多个表，使用join关键字，并且条件语句使用ON 而不是WHERE.</p><p>连接可以替换子查询，并且比子查询的效率一般会更快。</p><p>可以用AS给列名，计算字段和表名取名，给表明取别名是为了简化SQL语句以及连接相同的表。</p><h4 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h4><p>内连接又称等值连接，使用 INNER JOIN 关键字。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A.value, B.value</span><br><span class="line"><span class="keyword">FROM</span> tablea <span class="keyword">AS</span> A <span class="keyword">INNER</span> <span class="keyword">JOIN</span> tableb <span class="keyword">AS</span> B</span><br><span class="line"><span class="keyword">ON</span> A.key = B.key;</span><br></pre></td></tr></table></figure><p>可以不明确使用 INNER JOIN，而使用普通查询并在 WHERE 中将两个表中要连接的列用等值方法连接起来。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A.value, B.value</span><br><span class="line"><span class="keyword">FROM</span> tablea <span class="keyword">AS</span> A, tableb <span class="keyword">AS</span> B</span><br><span class="line"><span class="keyword">WHERE</span> A.key = B.key;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;注释：&quot;&gt;&lt;a href=&quot;#注释：&quot; class=&quot;headerlink&quot; title=&quot;注释：&quot;&gt;&lt;/a&gt;注释：&lt;/h3&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;spa
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>0301每日一题</title>
    <link href="http://yoursite.com/2020/03/01/0301%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    <id>http://yoursite.com/2020/03/01/0301%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</id>
    <published>2020-03-01T14:10:57.508Z</published>
    <updated>2020-03-01T15:29:29.220Z</updated>
    
    <content type="html"><![CDATA[<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>来源：ssrcoder</p><p>以下代码的输出结果是？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span>  Main t1 = <span class="keyword">new</span> Main();</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span>  Main t2 = <span class="keyword">new</span> Main();</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"构造块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"静态块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        Main t = <span class="keyword">new</span> Main();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>A.静态块 构造块 构造块 构造块</strong><br><strong>B.构造块 静态块 构造块 构造块</strong><br><strong>C.构造块 构造块 静态块 构造块</strong><br><strong>D.构造块 构造块 构造块 静态块</strong></li></ul><ul><li><h2 id="执行顺序：静态代码块-gt-构造代码块-gt-构造方法"><a href="#执行顺序：静态代码块-gt-构造代码块-gt-构造方法" class="headerlink" title="执行顺序：静态代码块&gt;构造代码块&gt;构造方法"></a>执行顺序：静态代码块&gt;构造代码块&gt;构造方法</h2></li></ul><p>理由：静态代码块（<strong>static{}</strong>）在类加载的时候执行一次。 </p><p>​             构造代码块（<strong>{}内的部分</strong>）在每一次创建对象时执行，始终在构造方法前执行。 </p><p>​              构造方法在新建对象时调用（   就是<strong>new的时候</strong>      ）。 </p><p> 注意： <strong>a.静态代码块在类加载的时候就执行，所以它的优先级高于入口main()方法。</strong> </p><p>​              b.当三种形式不止一次出现，同优先级是按照先后顺序执行。</p><p>​              c.静态域中包含静态变量、静态块和静态方法,其中需要初始化的是静态变量和静态块.而他们两个的初始化顺序是靠他们俩的位置决定的</p><p>​        首先加载类B，执行静态域的第一个静态变量，static b1=new B，输出构造块和构造方法（空）。<strong>因为执行了静态变量的初始化，意味着已经加载了B的静态域的一部分，这时候不能再加载另一个静态域了，否则属于重复加载 了</strong>（静态域必须当成一个整体来看待。否则加载会错乱）   于是，依次static b2 =new B，输出构造块，再执行静态块，完成对整个静态域的加载，再执行main方法，new b，输出构造块。  </p><p>因此会先打印两个“构造块”，接着在执行执行静态代码块，打印静态块；最后再打印一个“构造块”。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;例题&quot;&gt;&lt;a href=&quot;#例题&quot; class=&quot;headerlink&quot; title=&quot;例题&quot;&gt;&lt;/a&gt;例题&lt;/h2&gt;&lt;p&gt;来源：ssrcoder&lt;/p&gt;
&lt;p&gt;以下代码的输出结果是？&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;tab
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>0229每日一题</title>
    <link href="http://yoursite.com/2020/02/29/0229%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    <id>http://yoursite.com/2020/02/29/0229%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</id>
    <published>2020-02-29T13:41:19.126Z</published>
    <updated>2020-03-01T14:11:12.582Z</updated>
    
    <content type="html"><![CDATA[<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>来源：ssrcoder</p><p>假设如下代码中，若t1线程在t2线程启动之前已经完成启动。代码的输出是（） </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fzzf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        obj.wait();</span><br><span class="line">                        System.out.println(<span class="string">"thread 1 wake up."</span>);</span><br><span class="line">                    &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t1.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">                    obj.notifyAll();</span><br><span class="line">                    System.out.println(<span class="string">"thread 2 sent notify"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>A.Thread 1 wake up</strong><br>    <strong>Thread 2 sent notify.</strong><br><strong>B.Thread 2 sent notify.</strong><br>    <strong>Thread 1 wake up</strong><br><strong>C.A、B皆有可能</strong><br><strong>D.程序无输出卡死</strong></p><a id="more"></a><h2 id="线程间协作：wait-，-notify，-notifyAll"><a href="#线程间协作：wait-，-notify，-notifyAll" class="headerlink" title="线程间协作：wait ，  notify， notifyAll"></a>线程间协作：wait ，  notify， notifyAll</h2><p>在 Java 中，可以通过配合调用 Object 对象的 wait() 方法和 notify()方法或 notifyAll()   方法来实现线程间的通信。在线程中调用 wait() 方法，将阻塞等待其他线程的通知（其他线程调用 notify() 方法或   notifyAll() 方法），在线程中调用 notify() 方法或 notifyAll() 方法，将通知其他线程从 wait() 方法处返回。</p><p>Object 是所有类的超类，它有 5   个方法组成了等待/通知机制的核心：notify()、notifyAll()、wait()、wait(long)和   wait(long，int)。在 Java 中，所有的类都从 Object   继承而来，因此，所有的类都拥有这些共有方法可供使用。而且，由于他们都被声明为 final，因此<strong>在子类中不能覆写任何一个方法</strong>。</p><h2 id="wait"><a href="#wait" class="headerlink" title="wait()"></a>wait()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.wait(<span class="number">0L</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> var1)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeoutMillis, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timeoutMillis &lt; <span class="number">0L</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeoutMillis value is negative"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt;= <span class="number">0</span> &amp;&amp; nanos &lt;= <span class="number">999999</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ++timeoutMillis;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.wait(timeoutMillis);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"nanosecond timeout value out of range"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法用来将当前线程置入休眠状态，直到接到通知或被中断为止。在调用   wait()之前，线程必须要获得该对象的对象级别锁，即只能在同步方法或同步块中调用 wait()方法。进入   wait()方法后，当前线程释放锁。在从 wait()返回前，线程与其他线程竞争重新获得锁。如果调用   wait()时，没有持有适当的锁，则抛出 IllegalMonitorStateException，它是 RuntimeException   的一个子类，因此，不需要 try-catch 结构。  </p><h2 id="notify"><a href="#notify" class="headerlink" title="notify()"></a>notify()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>该方法也要在同步块中调用，即在调用前，线程也必须要获得该对象的对象级别锁，如果调用notify()时没有持有适当的锁，也会抛出 IllegalMonitorStateException。</p><p>该方法用来通知那些可能等待该对象的对象锁的其他线程。如果有多个线程等待，则线程规划器任意挑选出其中一个   wait()状态的线程来发出通知，并使它等待获取该对象的对象锁（notify 后，当前线程不会马上释放该对象锁，wait   所在的线程并不能马上获取该对象锁，要等到程序退出 synchronized   代码块后，当前线程才会释放锁，wait所在的线程也才可以获取该对象锁），但不惊动其他同样在等待被该对象notify的线程们。  </p><p>当第一个获得了该对象锁的wait线程运行完毕以后，它会释放掉对象锁，此时如果该对象没有再次使用 notify 语句，则即便该对象已经空闲，其他 wait   状态等待的线程由于没有得到该对象的通知，会继续阻塞在 wait 状态，直到这个对象发出一个 notify 或   notifyAll。</p><h2 id="notifyAll"><a href="#notifyAll" class="headerlink" title="notifyAll()"></a>notifyAll()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>该方法与 notify ()方法的工作方式相同，重要的一点差异是：</p><p>notifyAll 使所有原来在该对象上 wait 的线程统统退出 wait 的状态（即全部被唤醒，不再等待 notify 或   notifyAll，但由于此时还没有获取到该对象锁，因此还不能继续往下执行），变成等待获取该对象上的锁，一旦该对象锁被释放（notifyAll   线程退出调用了 notifyAll 的 synchronized   代码块的时候），他们就会去竞争。如果其中一个线程获得了该对象锁，它就会继续往下执行，在它退出 synchronized 代码块，释放锁后，其他的已经被唤醒的线程将会继续竞争获取该锁，一直进行下去，直到所有被唤醒的线程都执行完毕。</p><h2 id="回到本题："><a href="#回到本题：" class="headerlink" title="回到本题："></a>回到本题：</h2><p>执行obj.wait()； 已经释放锁；所以t2可以再次获取到obj；唤醒t1，等到t2执行完毕，释放锁后再继续执行t1。</p><p>因此输出如下：</p><p><code>thread 2 sent notify</code><br><code>thread 1 wake up.</code></p><p>所以选择B项。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;例题&quot;&gt;&lt;a href=&quot;#例题&quot; class=&quot;headerlink&quot; title=&quot;例题&quot;&gt;&lt;/a&gt;例题&lt;/h2&gt;&lt;p&gt;来源：ssrcoder&lt;/p&gt;
&lt;p&gt;假设如下代码中，若t1线程在t2线程启动之前已经完成启动。代码的输出是（） &lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;package&lt;/span&gt; com.fzzf;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Main&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; Exception&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; Object obj = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Object();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Thread t1 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Thread()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;synchronized&lt;/span&gt; (obj)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        obj.wait();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;thread 1 wake up.&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &amp;#125;&lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt;(InterruptedException e)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        t1.start();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Thread.sleep(&lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Thread t2 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Thread()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;synchronized&lt;/span&gt; (obj)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    obj.notifyAll();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;thread 2 sent notify&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        t2.start();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;A.Thread 1 wake up&lt;/strong&gt;&lt;br&gt;    &lt;strong&gt;Thread 2 sent notify.&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;B.Thread 2 sent notify.&lt;/strong&gt;&lt;br&gt;    &lt;strong&gt;Thread 1 wake up&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;C.A、B皆有可能&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;D.程序无输出卡死&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Java设计原则</title>
    <link href="http://yoursite.com/2020/02/28/Java%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    <id>http://yoursite.com/2020/02/28/Java%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</id>
    <published>2020-02-28T05:17:53.467Z</published>
    <updated>2020-02-28T15:35:16.901Z</updated>
    
    <content type="html"><![CDATA[<h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><p><strong>单一职责原则</strong>：修改类的原因应该只有一个，一个类只负责一个事。</p><p><strong>开放封闭原则</strong>：类应该对扩展开放，对修改关闭。</p><p><strong>里氏替换原则</strong>：子类的对象必须能够替换掉所有父类对象。子类需要能够当成父类来使用，并且需要比父类更加特殊。</p><p><strong>接口分离原则</strong>：不应该强迫客户依赖于它们不用的方法。</p><p><strong>依赖倒置原则</strong>：<strong>高层模块不应该依赖于底层模块</strong>；二者都应该依赖于抽象；抽象不应该依赖于细节，细节应该依赖于抽象。</p><p><strong>迪米特法则</strong>：最少知识原则，一个对象对其他对象有尽可能少的了解，不和陌生人说话。</p><p><strong>合成复用原则</strong>：尽量使用对象组合，而不是通过继承来达到复用的目的。</p><blockquote><p>  <strong>共同封闭原则</strong>：一起的类应该组合在一起(同一个包里)，如果必须修改应用程序里的代码，我们希望所有的修改都发生在一个包里（修改关闭），而不是遍布在很多包里。</p><p>  <strong>稳定抽象原则</strong>：最稳定的包应该是最抽象的包，不稳定的包是具体的包，即包的抽象程度跟它的稳定性成正比。</p><p>  <strong>稳定依赖原则</strong>：包之间的依赖关系都应该是稳定方向的依赖，包要依赖的包要比自己更具有稳定性。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;设计原则&quot;&gt;&lt;a href=&quot;#设计原则&quot; class=&quot;headerlink&quot; title=&quot;设计原则&quot;&gt;&lt;/a&gt;设计原则&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;单一职责原则&lt;/strong&gt;：修改类的原因应该只有一个，一个类只负责一个事。&lt;/p&gt;
&lt;p&gt;&lt;strong
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Java基础复习(3)</title>
    <link href="http://yoursite.com/2020/02/28/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0(3)/"/>
    <id>http://yoursite.com/2020/02/28/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0(3)/</id>
    <published>2020-02-28T02:25:36.021Z</published>
    <updated>2020-02-28T03:29:31.865Z</updated>
    
    <content type="html"><![CDATA[<h2 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h2><p>重载：<strong>发生在同一个类中，方法名必须相同，参数类型不同，个数不同，顺序不同</strong>，方法返回值和访问修饰符也可以不同。</p><p><strong>Java允许重载任何方法，而不只是构造器方法。因此，要完整描述一个方法，需要指出方法名以及参数类型。这叫做方法签名。</strong></p><p>重写是子类对父类的允许访问的方法的实现过程进行重新编写,发生在子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。另外，如果父类方法访问修饰符为 private 则子类就不能重写该方法。<strong>也就是说方法提供的行为改变，而方法的外貌并没有改变。</strong></p><a id="more"></a><h2 id="Java-面向对象编程三大特性-封装-继承-多态"><a href="#Java-面向对象编程三大特性-封装-继承-多态" class="headerlink" title="Java 面向对象编程三大特性: 封装 继承 多态"></a>Java 面向对象编程三大特性: 封装 继承 多态</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。</p><p><strong>关于继承如下 3 点请记住：</strong></p><p>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</p><p>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</p><p>子类可以用自己的方式实现父类的方法。</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</p><p><strong>在 Java 中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）</strong>。</p><h2 id="装箱与拆箱"><a href="#装箱与拆箱" class="headerlink" title="装箱与拆箱"></a>装箱与拆箱</h2><p><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</p><p><strong>拆箱</strong>：将包装类型转换为基本数据类型；</p><h2 id="接口和抽象类的区别是什么？（重要）"><a href="#接口和抽象类的区别是什么？（重要）" class="headerlink" title="接口和抽象类的区别是什么？（重要）"></a>接口和抽象类的区别是什么？（重要）</h2><p>接口的方法默认是public， 所有方法在接口中不能有实现，而抽象类可以有非抽象的方法。</p><p>接口中除了static，final变量， 不能有其他变量，而抽象类中则不一定。</p><p>一个类可以实现多个接口，但是只能实现一个抽象类，接口本身可以通过extends关键字扩展多个接口。</p><p>接口方法默认修饰符是 public，抽象方法可以有 public、protected 和 default 这些修饰符（抽象方法就是为了被重写所以不能使用 private 关键字修饰！）。</p><p>从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。</p><h3 id="一个类的构造方法的作用是什么-若一个类没有声明构造方法，该程序能正确执行吗-为什么"><a href="#一个类的构造方法的作用是什么-若一个类没有声明构造方法，该程序能正确执行吗-为什么" class="headerlink" title="一个类的构造方法的作用是什么? 若一个类没有声明构造方法，该程序能正确执行吗? 为什么?"></a>一个类的构造方法的作用是什么? 若一个类没有声明构造方法，该程序能正确执行吗? 为什么?</h3><p>主要作用是完成对类对象的初始化工作。可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。</p><h3 id="构造方法有哪些特性？"><a href="#构造方法有哪些特性？" class="headerlink" title="构造方法有哪些特性？"></a>构造方法有哪些特性？</h3><p>名字与类名相同。</p><p>没有返回值，但不能用 void 声明构造函数。</p><p>生成类的对象时自动执行，无需调用。</p><h2 id="成员变量与局部变量的区别有哪些？"><a href="#成员变量与局部变量的区别有哪些？" class="headerlink" title="成员变量与局部变量的区别有哪些？"></a>成员变量与局部变量的区别有哪些？</h2><p>语法形式上看：成员变量是属于类的，而局部变量是在方法中定义的变量或者是方法的参数；成员变量可以被public,private,static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰。</p><p>从变量在内存中的存储方式来看:如果成员变量是使用<code>static</code>修饰的，那么这个成员变量是属于类的，如果没有使用<code>static</code>修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。</p><p>从变量在内存中的生存时间上看:成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。</p><p>成员变量如果没有被赋初值:则会自动以类型的默认值而赋值（一种情况例外:被 final 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;重载和重写的区别&quot;&gt;&lt;a href=&quot;#重载和重写的区别&quot; class=&quot;headerlink&quot; title=&quot;重载和重写的区别&quot;&gt;&lt;/a&gt;重载和重写的区别&lt;/h2&gt;&lt;p&gt;重载：&lt;strong&gt;发生在同一个类中，方法名必须相同，参数类型不同，个数不同，顺序不同&lt;/strong&gt;，方法返回值和访问修饰符也可以不同。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Java允许重载任何方法，而不只是构造器方法。因此，要完整描述一个方法，需要指出方法名以及参数类型。这叫做方法签名。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;重写是子类对父类的允许访问的方法的实现过程进行重新编写,发生在子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。另外，如果父类方法访问修饰符为 private 则子类就不能重写该方法。&lt;strong&gt;也就是说方法提供的行为改变，而方法的外貌并没有改变。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Java基础复习(2)</title>
    <link href="http://yoursite.com/2020/02/28/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0(2)/"/>
    <id>http://yoursite.com/2020/02/28/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0(2)/</id>
    <published>2020-02-28T01:45:01.779Z</published>
    <updated>2020-02-28T02:58:52.787Z</updated>
    
    <content type="html"><![CDATA[<h1 id="final-static-this-super-关键字总结"><a href="#final-static-this-super-关键字总结" class="headerlink" title="final,static,this,super 关键字总结"></a>final,static,this,super 关键字总结</h1><h2 id="final-关键字"><a href="#final-关键字" class="headerlink" title="final 关键字"></a>final 关键字</h2><p><strong>final关键字主要用在三个地方：变量、方法、类。</strong></p><p><strong>1.对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。</strong></p><p>2.<strong>当用final修饰一个类时，表明这个类不能被继承。final类中的所有成员方法都会被隐式地指定为final方法。</strong></p><p>3.使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的Java版本已经不需要使用final方法进行这些优化了）。类中所有的private方法都隐式地指定为final。</p><a id="more"></a><h2 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a>this 关键字</h2><p>this关键字用于引用类的当前实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span> </span>&#123;</span><br><span class="line">    Employees[] employees;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">manageEmployees</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> totalEmp = <span class="keyword">this</span>.employees.length;<span class="comment">//访问类Manger的当前实例的变量</span></span><br><span class="line">        System.out.println(<span class="string">"Total employees: "</span> + totalEmp);</span><br><span class="line">        <span class="keyword">this</span>.report();<span class="comment">//调用类Manger的当前实力放法。</span></span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">report</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此关键字是可选的，这意味着如果上面的示例在不使用此关键字的情况下表现相同。 但是，使用此关键字可能会使代码更易读或易懂。</p><p>此关键字是可选的，这意味着如果上面的示例在不使用此关键字的情况下表现相同。 但是，使用此关键字可能会使代码更易读或易懂。</p><h2 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h2><p>super关键字用于从子类访问父类的变量和方法。 例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> number;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">showNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"number = "</span> + number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.number = <span class="number">10</span>;<span class="comment">// 访问父类成员变量，</span></span><br><span class="line">        <span class="keyword">super</span>.showNumber();<span class="comment">//调用其父类的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用 this 和 super 要注意的问题：</strong></p><p>在构造器中使用 <code>super（）</code> 调用父类中的其他构造方法时，该语句必须处于构造器的首行，否则编译器会报错。另外，this 调用本类中的其他构造方法时，也要放在首行。</p><p>this、super不能用在static方法中。</p><p><strong>简单解释一下：</strong></p><p>被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享。而 this 代表对本类对象的引用，指向本类对象；而 super 代表对父类对象的引用，指向父类对象；所以， <strong>this和super是属于对象范畴的东西，而静态方法是属于类范畴的东西</strong>。</p><h1 id="static-关键字详解"><a href="#static-关键字详解" class="headerlink" title="static 关键字详解"></a>static 关键字详解</h1><h2 id="static-关键字主要有以下四种使用场景"><a href="#static-关键字主要有以下四种使用场景" class="headerlink" title="static 关键字主要有以下四种使用场景"></a>static 关键字主要有以下四种使用场景</h2><p>修饰成员变量和成员方法</p><p>静态代码块</p><p>修饰类(只能修饰内部类)</p><p>静态导包(用来导入类中的静态资源，1.5之后的新特性)</p><h3 id="修饰成员变量和成员方法"><a href="#修饰成员变量和成员方法" class="headerlink" title="修饰成员变量和成员方法"></a>修饰成员变量和成员方法</h3><p>被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以并且建议通过类名调用。被static 声明的成员变量属于静态成员变量，静态变量 存放在 Java 内存区域的方法区。</p><p>方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。</p><p>调用格式：</p><ul><li>类名.静态变量名</li><li>类名.静态方法名()</li></ul><p>如果变量或者方法被 private 则代表该属性或者该方法只能在类的内部被访问而不能在类的外部被访问。</p><h3 id="静态方法与非静态方法"><a href="#静态方法与非静态方法" class="headerlink" title="静态方法与非静态方法"></a>静态方法与非静态方法</h3><p>静态方法属于类本身，非静态方法属于从该类生成的每个对象。 如果您的方法执行的操作不依赖于其类的各个变量和方法，请将其设置为静态（这将使程序的占用空间更小）。 否则，它应该是非静态的。</p><p><strong><em>Example 1</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Foo</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; </span><br><span class="line">       <span class="keyword">this</span>.i = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> An example string that doesn<span class="string">'t depend on i (an instance variable);</span></span><br><span class="line"><span class="string">       </span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    public int method2() &#123;</span></span><br><span class="line"><span class="string">       return this.i + 1;  Depends on i</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>你可以像这样调用静态方法：<code>Foo.method1（）</code>。 如果您尝试使用这种方法调用 method2 将失败。 但这样可行：<code>Foo bar = new Foo（1）;bar.method2（）;</code></p><p>总结：</p><p>在外部调用静态方法时，可以使用 类名.方法名 的方式，也可以使用 对象名.方法名 的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。</p><p>静态方法在访问本类的成员时，只允许访问静态成员(静态成员变量和静态方法)，而不允许访问实例成员变量和实例方法；实例方法则无此限制。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;final-static-this-super-关键字总结&quot;&gt;&lt;a href=&quot;#final-static-this-super-关键字总结&quot; class=&quot;headerlink&quot; title=&quot;final,static,this,super 关键字总结&quot;&gt;&lt;/a&gt;final,static,this,super 关键字总结&lt;/h1&gt;&lt;h2 id=&quot;final-关键字&quot;&gt;&lt;a href=&quot;#final-关键字&quot; class=&quot;headerlink&quot; title=&quot;final 关键字&quot;&gt;&lt;/a&gt;final 关键字&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;final关键字主要用在三个地方：变量、方法、类。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2.&lt;strong&gt;当用final修饰一个类时，表明这个类不能被继承。final类中的所有成员方法都会被隐式地指定为final方法。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;3.使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的Java版本已经不需要使用final方法进行这些优化了）。类中所有的private方法都隐式地指定为final。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Java集合框架(一)</title>
    <link href="http://yoursite.com/2020/02/27/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6(%E4%B8%80)/"/>
    <id>http://yoursite.com/2020/02/27/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6(%E4%B8%80)/</id>
    <published>2020-02-27T13:21:29.708Z</published>
    <updated>2020-02-27T13:58:05.188Z</updated>
    
    <content type="html"><![CDATA[<h2 id="说说List-Set-Map三者的区别？"><a href="#说说List-Set-Map三者的区别？" class="headerlink" title="说说List,Set,Map三者的区别？"></a>说说List,Set,Map三者的区别？</h2><p><strong>List：</strong> List接口存储一组不唯一（可以有多个元素引用相同的对象），有序的对象</p><p><strong>Set:</strong> 不允许重复的集合。不会有多个元素引用相同的对象。</p><p><strong>Map:</strong> 使用键值对存储。Map会维护与Key有关联的值。两个Key可以引用相同的对象，但Key不能重复，典型的Key是String类型，但也可以是任何对象。</p><a id="more"></a><h2 id="ArrayList-与-LinkedList-区别"><a href="#ArrayList-与-LinkedList-区别" class="headerlink" title="ArrayList 与 LinkedList 区别?"></a>ArrayList 与 LinkedList 区别?</h2><p><strong>1.是否保证线程安全**</strong>：ArrayList和LinkedList 都是不同步的，也就是都不保证线程安全。</p><p><strong>2.底层数据结构：</strong> <code>Arraylist</code> 底层使用的是 <strong>Object 数组</strong>；<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构（JDK1.6之前为循环链表，JDK1.7取消了循环。注意双向链表和双向循环链表的区别）</p><p><strong>3</strong>.<strong>插入和删除是受元素位置的影响</strong>：数组存储和链表存储的区别。</p><p><strong>4.是否支持快速随机访问：</strong>LinkedList 不支持高效的随机元素访问，而 ArrayList 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于get(int index) 方法)。</p><p><strong>5.内存空间占用：</strong> ArrayList的空 间浪费主要体现在在list列表的结尾会预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗比ArrayList更多的空间（因为要存放直接后继和直接前驱以及数据）</p><h2 id="HashMap-和-Hashtable-的区别"><a href="#HashMap-和-Hashtable-的区别" class="headerlink" title="HashMap 和 Hashtable 的区别"></a>HashMap 和 Hashtable 的区别</h2><p><strong>线程是否安全：</strong> HashMap 是非线程安全的，HashTable 是线程安全的；HashTable 内部的方法基本都经过synchronized 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）；</p><p><strong>效率：</strong> 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；</p><p><strong>对Null key 和Null value的支持：</strong> HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛出 NullPointerException。</p><p><strong>初始容量大小和每次扩充容量大小的不同 ：</strong> ①创建时如果不指定容量初始值，Hashtable 默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。②创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次方大小（HashMap 中的tableSizeFor()方法保证，下面给出了源代码）。也就是说 HashMap 总是使用2的幂作为哈希表的大小,后面会介绍到为什么是2的幂次方。</p><p><strong>底层数据结构：</strong> JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</p><h2 id="String-StringBuffer-和-StringBuilder-的区别是什么-String-为什么是不可变的"><a href="#String-StringBuffer-和-StringBuilder-的区别是什么-String-为什么是不可变的" class="headerlink" title="String StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?"></a>String StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?</h2><p>String 类中使用 final 关键字修饰字符数组来保存字符串，String对象是不可变的。</p><p>StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串 char[] value但是没有用 final 关键字修饰，所以这两种对象都是可变的。</p><p><strong>线程安全性</strong>：String 中的对象是不可变的，也就可以理解为常量，线程安全。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。　</p><p><strong>性能</strong>：每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p><p>对于三者使用的总结：</p><p><strong>操作少量的数据: 适用String</strong></p><p><strong>单线程操作字符串缓冲区下操作大量数据: 适用StringBuilder</strong></p><p><strong>多线程操作字符串缓冲区下操作大量数据: 适用StringBuffer</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;说说List-Set-Map三者的区别？&quot;&gt;&lt;a href=&quot;#说说List-Set-Map三者的区别？&quot; class=&quot;headerlink&quot; title=&quot;说说List,Set,Map三者的区别？&quot;&gt;&lt;/a&gt;说说List,Set,Map三者的区别？&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;List：&lt;/strong&gt; List接口存储一组不唯一（可以有多个元素引用相同的对象），有序的对象&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Set:&lt;/strong&gt; 不允许重复的集合。不会有多个元素引用相同的对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Map:&lt;/strong&gt; 使用键值对存储。Map会维护与Key有关联的值。两个Key可以引用相同的对象，但Key不能重复，典型的Key是String类型，但也可以是任何对象。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Java基础复习(1)</title>
    <link href="http://yoursite.com/2020/02/27/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0(1)/"/>
    <id>http://yoursite.com/2020/02/27/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0(1)/</id>
    <published>2020-02-27T03:44:58.446Z</published>
    <updated>2020-02-27T12:45:12.715Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-为什么Java中只有值传递"><a href="#一-为什么Java中只有值传递" class="headerlink" title="一. 为什么Java中只有值传递"></a>一. 为什么Java中只有值传递</h2><p><strong>Java 程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。</strong></p><p><strong><em>example 1</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> num2 = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    swap(num1, num2);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"num1 = "</span> + num1);</span><br><span class="line">    System.out.println(<span class="string">"num2 = "</span> + num2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"a = "</span> + a);</span><br><span class="line">    System.out.println(<span class="string">"b = "</span> + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>result 1</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">20</span></span><br><span class="line">b = <span class="number">10</span></span><br><span class="line">num1 = <span class="number">10</span></span><br><span class="line">num2 = <span class="number">20</span></span><br></pre></td></tr></table></figure><p>在 swap 方法中，a、b 的值进行交换，并不会影响到 num1、num2。因为，a、b 中的值，只是从 num1、num2 的复制过来的。也就是说，a、b 相当于 num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身。</p><a id="more"></a><p><strong>一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样，请看 example2.</strong></p><p><strong><em>example 2</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">change(arr);</span><br><span class="line">System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 将数组的第一个元素变为0</span></span><br><span class="line">array[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>result 2</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><p>array 被初始化 arr 的拷贝也就是一个对象的引用，也就是说 array 和 arr 指向的是同一个数组对象。 因此，外部对引用对象的改变会反映到所对应的对象上。</p><p><strong>通过 example 2 我们已经看到，实现一个改变对象参数状态的方法并不是一件难事。理由很简单，方法得到的是对象引用的拷贝，对象引用及其他的拷贝同时引用同一个对象。</strong></p><p><strong><em>example 3</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Student s1 = <span class="keyword">new</span> Student(<span class="string">"小张"</span>);</span><br><span class="line">Student s2 = <span class="keyword">new</span> Student(<span class="string">"小李"</span>);</span><br><span class="line">Test.swap(s1, s2);</span><br><span class="line">System.out.println(<span class="string">"s1:"</span> + s1.getName());</span><br><span class="line">System.out.println(<span class="string">"s2:"</span> + s2.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Student x, Student y)</span> </span>&#123;</span><br><span class="line">Student temp = x;</span><br><span class="line">x = y;</span><br><span class="line">y = temp;</span><br><span class="line">System.out.println(<span class="string">"x:"</span> + x.getName());</span><br><span class="line">System.out.println(<span class="string">"y:"</span> + y.getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x:小李</span><br><span class="line">y:小张</span><br><span class="line">s1:小张</span><br><span class="line">s2:小李</span><br></pre></td></tr></table></figure><p> <strong>方法并没有改变存储在变量 s1 和 s2 中的对象引用。swap 方法的参数 x 和 y 被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝</strong>。</p><p><strong>总结</strong></p><p>Java 程序设计语言对对象采用的不是引用调用，实际上，对象引用是按 值传递的。</p><p>下面再总结一下 Java 中方法参数的使用情况：</p><ul><li>一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）。</li><li>一个方法可以改变一个对象参数的状态。</li><li>一个方法不能让对象参数引用一个新的对象。</li></ul><h2 id="二-与-equals-重要"><a href="#二-与-equals-重要" class="headerlink" title="二 .==与 equals(重要)"></a>二 .==与 equals(重要)</h2><p><strong>==</strong> : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)</p><p><strong>equals()</strong> : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：</p><ul><li><p>情况 1：类没有覆盖 equals()方法。则通过 equals()比较该类的两个对象时，等价于通过“==”比较这两个对象。</p></li><li><p>情况 2：类覆盖了 equals()方法。一般，我们都覆盖 equals()方法来两个对象的内容相等；若它们的内容相等，则返回 true(即，认为这两个对象相等)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String a = <span class="keyword">new</span> String(<span class="string">"ab"</span>); <span class="comment">// a 为一个引用</span></span><br><span class="line">        String b = <span class="keyword">new</span> String(<span class="string">"ab"</span>); <span class="comment">// b为另一个引用,对象的内容一样</span></span><br><span class="line">        String aa = <span class="string">"ab"</span>; <span class="comment">// 放在常量池中</span></span><br><span class="line">        String bb = <span class="string">"ab"</span>; <span class="comment">// 从常量池中查找</span></span><br><span class="line">        <span class="keyword">if</span> (aa == bb) <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">"aa==bb"</span>);</span><br><span class="line">        <span class="keyword">if</span> (a == b) <span class="comment">// false，非同一对象</span></span><br><span class="line">            System.out.println(<span class="string">"a==b"</span>);</span><br><span class="line">        <span class="keyword">if</span> (a.equals(b)) <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">"aEQb"</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">42</span> == <span class="number">42.0</span>) &#123; <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">"true"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>说明：</strong></p><p>String 中的 equals 方法是被重写过的，因为 object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。</p><p>当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。          </p><p>​                                                     </p><h2 id="三-什么是反射机制？-反射机制的应用场景有哪些？"><a href="#三-什么是反射机制？-反射机制的应用场景有哪些？" class="headerlink" title="三. 什么是反射机制？ 反射机制的应用场景有哪些？"></a>三. 什么是反射机制？ 反射机制的应用场景有哪些？</h2><h3 id="反射机制介绍"><a href="#反射机制介绍" class="headerlink" title="反射机制介绍"></a>反射机制介绍</h3><p>JAVA 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 java 语言的反射机制。</p><h3 id="静态编译和动态编译"><a href="#静态编译和动态编译" class="headerlink" title="静态编译和动态编译"></a>静态编译和动态编译</h3><ul><li><strong>静态编译：</strong>在编译时确定类型，绑定对象</li><li><strong>动态编译：</strong>运行时确定类型，绑定对象</li></ul><h3 id="反射机制优缺点"><a href="#反射机制优缺点" class="headerlink" title="反射机制优缺点"></a>反射机制优缺点</h3><ul><li><strong>优点：</strong> 运行期类型的判断，动态加载类，提高代码灵活度。</li><li><strong>缺点：</strong> 性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的 java 代码要慢很多。</li></ul><h3 id="反射的应用场景"><a href="#反射的应用场景" class="headerlink" title="反射的应用场景"></a>反射的应用场景</h3><p><strong>反射是框架设计的灵魂。</strong></p><p>在我们平时的项目开发过程中，基本上很少会直接使用到反射机制，但这不能说明反射机制没有用，实际上有很多设计、开发都与反射机制有关，例如模块化的开发，通过反射去调用对应的字节码；动态代理设计模式也采用了反射机制，还有我们日常使用的 Spring／Hibernate 等框架也大量使用到了反射机制。</p><p>举例：① 我们在使用 JDBC 连接数据库时使用 <code>Class.forName()</code>通过反射加载数据库的驱动程序；②Spring 框架也用到很多反射机制，最经典的就是 xml 的配置模式。Spring 通过 XML 配置模式装载 Bean 的过程：1) 将程序内所有 XML 或 Properties 配置文件加载入内存中; 2)Java 类里面解析 xml 或 properties 里面的内容，得到对应实体类的字节码字符串以及相关的属性信息; 3)使用反射机制，根据这个字符串获得某个类的 Class 实例; 4)动态配置实例的属性。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一-为什么Java中只有值传递&quot;&gt;&lt;a href=&quot;#一-为什么Java中只有值传递&quot; class=&quot;headerlink&quot; title=&quot;一. 为什么Java中只有值传递&quot;&gt;&lt;/a&gt;一. 为什么Java中只有值传递&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Java 程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;example 1&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; num1 = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; num2 = &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    swap(num1, num2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;num1 = &quot;&lt;/span&gt; + num1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;num2 = &quot;&lt;/span&gt; + num2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;swap&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; b)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; temp = a;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    a = b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    b = temp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;a = &quot;&lt;/span&gt; + a);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;b = &quot;&lt;/span&gt; + b);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;result 1&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;a = &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;b = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;num1 = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;num2 = &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;p&gt;在 swap 方法中，a、b 的值进行交换，并不会影响到 num1、num2。因为，a、b 中的值，只是从 num1、num2 的复制过来的。也就是说，a、b 相当于 num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>单例模式(1)</title>
    <link href="http://yoursite.com/2020/02/26/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F(1)/"/>
    <id>http://yoursite.com/2020/02/26/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F(1)/</id>
    <published>2020-02-26T15:48:32.285Z</published>
    <updated>2020-02-27T12:45:27.070Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><p><strong>1.手写单例模式</strong></p><p><strong>2.线程安全的单例模式</strong></p><h2 id="什么是单例模式"><a href="#什么是单例模式" class="headerlink" title="什么是单例模式"></a>什么是单例模式</h2><p>单例模式在整个程序中只能有一个实例，这个类负责创建自己的对象，并确保只有一个对象被创建。</p><h2 id="代码实现的要点"><a href="#代码实现的要点" class="headerlink" title="代码实现的要点"></a>代码实现的要点</h2><p>a.私有构造器</p><p>b.持有该类的属性</p><p>c.对外提供获取实例的静态方法</p><a id="more"></a><h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">**</span><br><span class="line"> * <span class="meta">@author</span> Fzzf</span><br><span class="line"> * 饿汉式，类加载机制实现，线程安全；</span><br><span class="line"> * 缺点:容易造成浪费，对反射和反序列化是不安全的；</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Single1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Single1 instance = <span class="keyword">new</span> Single1();</span><br><span class="line">    <span class="comment">//持有该类的属性，类加载就实例化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Single1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//私有化构造器</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Single1 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对外提供获取实例的静态方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="登记式"><a href="#登记式" class="headerlink" title="登记式"></a>登记式</h2><p>注册登记式：每使用一次，都往一个固定的容器中去注册并且将使用过的对象进行缓存，下次去取对象的时候，就直接从缓存中取值，以保证每次获取的对象都是同一个对象，IOC的单例模式，就是典型的注册登记是单例。</p><p>登记式是对一组单例模式进行的维护；主要是在数量上的扩展，通过map我们把单例存进去，这样在调用时，先判断该单例是否已经创建，是的话直接返回，不是的话创建一个登记到map中，再返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fzzf;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Fzzf</span></span><br><span class="line"><span class="comment"> * 单例模式-登记式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegSignleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, RegSignleton&gt; regs = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     静态工厂方法：返回指定登记对象的唯一实例</span></span><br><span class="line"><span class="comment">     @param name</span></span><br><span class="line"><span class="comment">     @return</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span>  <span class="keyword">static</span>  RegSignleton <span class="title">getInstance</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (name == <span class="keyword">null</span>)&#123;</span><br><span class="line">            name = RegSignleton<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(regs.get(name) == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                regs.put(name,(RegSignleton) Class.forName(name).newInstance());</span><br><span class="line">            &#125;<span class="keyword">catch</span>(InstantiationException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (IllegalAccessException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (ClassNotFoundException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> regs.get(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;常见问题&quot;&gt;&lt;a href=&quot;#常见问题&quot; class=&quot;headerlink&quot; title=&quot;常见问题&quot;&gt;&lt;/a&gt;常见问题&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;1.手写单例模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.线程安全的单例模式&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;什么是单例模式&quot;&gt;&lt;a href=&quot;#什么是单例模式&quot; class=&quot;headerlink&quot; title=&quot;什么是单例模式&quot;&gt;&lt;/a&gt;什么是单例模式&lt;/h2&gt;&lt;p&gt;单例模式在整个程序中只能有一个实例，这个类负责创建自己的对象，并确保只有一个对象被创建。&lt;/p&gt;
&lt;h2 id=&quot;代码实现的要点&quot;&gt;&lt;a href=&quot;#代码实现的要点&quot; class=&quot;headerlink&quot; title=&quot;代码实现的要点&quot;&gt;&lt;/a&gt;代码实现的要点&lt;/h2&gt;&lt;p&gt;a.私有构造器&lt;/p&gt;
&lt;p&gt;b.持有该类的属性&lt;/p&gt;
&lt;p&gt;c.对外提供获取实例的静态方法&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
</feed>
