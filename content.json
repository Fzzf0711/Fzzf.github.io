{"meta":{"title":"Fzzf的博客","subtitle":"想挣扎无法自拔","description":"退堂鼓手","author":"Fzzf","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"java基础复习(1)","slug":"java基础复习(1)","date":"2020-02-27T03:44:58.446Z","updated":"2020-02-27T12:45:12.715Z","comments":true,"path":"2020/02/27/java基础复习(1)/","link":"","permalink":"http://yoursite.com/2020/02/27/java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0(1)/","excerpt":"一. 为什么Java中只有值传递Java 程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。 example 1 123456789101112131415161718public static void main(String[] args) &#123; int num1 = 10; int num2 = 20; swap(num1, num2); System.out.println(\"num1 = \" + num1); System.out.println(\"num2 = \" + num2);&#125;public static void swap(int a, int b) &#123; int temp = a; a = b; b = temp; System.out.println(\"a = \" + a); System.out.println(\"b = \" + b);&#125; result 1 1234a = 20b = 10num1 = 10num2 = 20 在 swap 方法中，a、b 的值进行交换，并不会影响到 num1、num2。因为，a、b 中的值，只是从 num1、num2 的复制过来的。也就是说，a、b 相当于 num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身。","text":"一. 为什么Java中只有值传递Java 程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。 example 1 123456789101112131415161718public static void main(String[] args) &#123; int num1 = 10; int num2 = 20; swap(num1, num2); System.out.println(\"num1 = \" + num1); System.out.println(\"num2 = \" + num2);&#125;public static void swap(int a, int b) &#123; int temp = a; a = b; b = temp; System.out.println(\"a = \" + a); System.out.println(\"b = \" + b);&#125; result 1 1234a = 20b = 10num1 = 10num2 = 20 在 swap 方法中，a、b 的值进行交换，并不会影响到 num1、num2。因为，a、b 中的值，只是从 num1、num2 的复制过来的。也就是说，a、b 相当于 num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身。 一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样，请看 example2. example 2 1234567891011public static void main(String[] args) &#123; int[] arr = &#123; 1, 2, 3, 4, 5 &#125;; System.out.println(arr[0]); change(arr); System.out.println(arr[0]); &#125; public static void change(int[] array) &#123; // 将数组的第一个元素变为0 array[0] = 0; &#125; result 2 1210 array 被初始化 arr 的拷贝也就是一个对象的引用，也就是说 array 和 arr 指向的是同一个数组对象。 因此，外部对引用对象的改变会反映到所对应的对象上。 通过 example 2 我们已经看到，实现一个改变对象参数状态的方法并不是一件难事。理由很简单，方法得到的是对象引用的拷贝，对象引用及其他的拷贝同时引用同一个对象。 example 3 12345678910111213141516171819public class Test &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub Student s1 = new Student(\"小张\"); Student s2 = new Student(\"小李\"); Test.swap(s1, s2); System.out.println(\"s1:\" + s1.getName()); System.out.println(\"s2:\" + s2.getName()); &#125; public static void swap(Student x, Student y) &#123; Student temp = x; x = y; y = temp; System.out.println(\"x:\" + x.getName()); System.out.println(\"y:\" + y.getName()); &#125;&#125; 1234x:小李y:小张s1:小张s2:小李 方法并没有改变存储在变量 s1 和 s2 中的对象引用。swap 方法的参数 x 和 y 被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝。 总结 Java 程序设计语言对对象采用的不是引用调用，实际上，对象引用是按 值传递的。 下面再总结一下 Java 中方法参数的使用情况： 一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）。 一个方法可以改变一个对象参数的状态。 一个方法不能让对象参数引用一个新的对象。 二 .==与 equals(重要)== : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。(基本数据类型==比较的是值，引用数据类型==比较的是内存地址) equals() : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况： 情况 1：类没有覆盖 equals()方法。则通过 equals()比较该类的两个对象时，等价于通过“==”比较这两个对象。 情况 2：类覆盖了 equals()方法。一般，我们都覆盖 equals()方法来两个对象的内容相等；若它们的内容相等，则返回 true(即，认为这两个对象相等)。 1234567891011121314151617public class test1 &#123; public static void main(String[] args) &#123; String a = new String(\"ab\"); // a 为一个引用 String b = new String(\"ab\"); // b为另一个引用,对象的内容一样 String aa = \"ab\"; // 放在常量池中 String bb = \"ab\"; // 从常量池中查找 if (aa == bb) // true System.out.println(\"aa==bb\"); if (a == b) // false，非同一对象 System.out.println(\"a==b\"); if (a.equals(b)) // true System.out.println(\"aEQb\"); if (42 == 42.0) &#123; // true System.out.println(\"true\"); &#125; &#125;&#125; 说明： String 中的 equals 方法是被重写过的，因为 object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。 当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。 ​ 三. 什么是反射机制？ 反射机制的应用场景有哪些？反射机制介绍JAVA 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 java 语言的反射机制。 静态编译和动态编译 静态编译：在编译时确定类型，绑定对象 动态编译：运行时确定类型，绑定对象 反射机制优缺点 优点： 运行期类型的判断，动态加载类，提高代码灵活度。 缺点： 性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的 java 代码要慢很多。 反射的应用场景反射是框架设计的灵魂。 在我们平时的项目开发过程中，基本上很少会直接使用到反射机制，但这不能说明反射机制没有用，实际上有很多设计、开发都与反射机制有关，例如模块化的开发，通过反射去调用对应的字节码；动态代理设计模式也采用了反射机制，还有我们日常使用的 Spring／Hibernate 等框架也大量使用到了反射机制。 举例：① 我们在使用 JDBC 连接数据库时使用 Class.forName()通过反射加载数据库的驱动程序；②Spring 框架也用到很多反射机制，最经典的就是 xml 的配置模式。Spring 通过 XML 配置模式装载 Bean 的过程：1) 将程序内所有 XML 或 Properties 配置文件加载入内存中; 2)Java 类里面解析 xml 或 properties 里面的内容，得到对应实体类的字节码字符串以及相关的属性信息; 3)使用反射机制，根据这个字符串获得某个类的 Class 实例; 4)动态配置实例的属性。","categories":[],"tags":[]},{"title":"单例模式(1)","slug":"单例模式(1)","date":"2020-02-26T15:48:32.285Z","updated":"2020-02-27T12:45:27.070Z","comments":true,"path":"2020/02/26/单例模式(1)/","link":"","permalink":"http://yoursite.com/2020/02/26/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F(1)/","excerpt":"常见问题1.手写单例模式 2.线程安全的单例模式 什么是单例模式单例模式在整个程序中只能有一个实例，这个类负责创建自己的对象，并确保只有一个对象被创建。 代码实现的要点a.私有构造器 b.持有该类的属性 c.对外提供获取实例的静态方法","text":"常见问题1.手写单例模式 2.线程安全的单例模式 什么是单例模式单例模式在整个程序中只能有一个实例，这个类负责创建自己的对象，并确保只有一个对象被创建。 代码实现的要点a.私有构造器 b.持有该类的属性 c.对外提供获取实例的静态方法 饿汉式12345678910111213141516** * @author Fzzf * 饿汉式，类加载机制实现，线程安全； * 缺点:容易造成浪费，对反射和反序列化是不安全的； */public class Single1 &#123; private static Single1 instance = new Single1(); //持有该类的属性，类加载就实例化 private Single1()&#123; //私有化构造器 &#125; public static Single1 getInstance()&#123; return instance; &#125; //对外提供获取实例的静态方法&#125; 登记式注册登记式：每使用一次，都往一个固定的容器中去注册并且将使用过的对象进行缓存，下次去取对象的时候，就直接从缓存中取值，以保证每次获取的对象都是同一个对象，IOC的单例模式，就是典型的注册登记是单例。 登记式是对一组单例模式进行的维护；主要是在数量上的扩展，通过map我们把单例存进去，这样在调用时，先判断该单例是否已经创建，是的话直接返回，不是的话创建一个登记到map中，再返回。 1234567891011121314151617181920212223242526272829303132333435package com.fzzf;import java.util.HashMap;import java.util.Map;/** * @author Fzzf * 单例模式-登记式 */public class RegSignleton &#123; private static Map&lt;String, RegSignleton&gt; regs = new HashMap&lt;&gt;(); /* 静态工厂方法：返回指定登记对象的唯一实例 @param name @return */ protected static RegSignleton getInstance(String name)&#123; if (name == null)&#123; name = RegSignleton.class.getName(); &#125; if(regs.get(name) == null)&#123; try&#123; regs.put(name,(RegSignleton) Class.forName(name).newInstance()); &#125;catch(InstantiationException e)&#123; e.printStackTrace(); &#125;catch (IllegalAccessException e)&#123; e.printStackTrace(); &#125;catch (ClassNotFoundException e)&#123; e.printStackTrace(); &#125; &#125; return regs.get(name); &#125;&#125;","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2020-02-26T07:50:17.400Z","updated":"2020-02-26T07:50:17.401Z","comments":true,"path":"2020/02/26/hello-world/","link":"","permalink":"http://yoursite.com/2020/02/26/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}